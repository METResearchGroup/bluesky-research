"""Constants for service."""

from lib.constants import root_local_data_directory

import os

MAP_SERVICE_TO_METADATA = {
    "backfill_sync": {
        "timestamp_field": "synctimestamp",
        "skip_date_validation": True,  # we're OK having older records, this is true
        # for stuff like follows where we want a full record of all their follows.
    },  # managed by raw_sync.
    "raw_sync": {
        "local_prefix": os.path.join(root_local_data_directory, "raw_sync"),
        "s3_prefix": "raw_sync",
        "glue_table_name": "raw_sync",
        "primary_key": "",
        "timestamp_field": "synctimestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "skip_date_validation": True,  # we're OK having older records.
        # NOTE: schemas are pyarrow schemas.
        "dtypes_map": {
            "post": {
                "uri": "string",
                "cid": "string",
                "author": "string",
                "py_type": "string",
                "created_at": "string",
                "text": "string",
                "embed": "string",
                "entities": "string",
                "facets": "string",
                "labels": "string",
                "langs": "string",
                "tags": "string",
                "record_type": "string",
                "synctimestamp": "string",
            },
            "reply": {
                "uri": "string",
                "cid": "string",
                "author": "string",
                "py_type": "string",
                "created_at": "string",
                "text": "string",
                "embed": "string",
                "entities": "string",
                "facets": "string",
                "reply": "string",
                "labels": "string",
                "langs": "string",
                "tags": "string",
                "record_type": "string",
                "synctimestamp": "string",
            },
            "repost": {
                "uri": "string",
                "cid": "string",
                "author": "string",
                "py_type": "string",
                "created_at": "string",
                "subject": "string",
                "record_type": "string",
                "synctimestamp": "string",
            },
            "like": {
                "uri": "string",
                "cid": "string",
                "author": "string",
                "py_type": "string",
                "created_at": "string",
                "subject": "string",
                "record_type": "string",
                "synctimestamp": "string",
            },
            "follow": {
                "uri": "string",
                "cid": "string",
                "author": "string",
                "py_type": "string",
                "created_at": "string",
                "subject": "string",
                "record_type": "string",
                "synctimestamp": "string",
            },
            "block": {
                "uri": "string",
                "cid": "string",
                "author": "string",
                "py_type": "string",
                "created_at": "string",
                "subject": "string",
                "record_type": "string",
                "synctimestamp": "string",
            },
        },
        "subpaths": {
            "like": os.path.join(
                root_local_data_directory, "raw_sync", "create", "like"
            ),
            "post": os.path.join(
                root_local_data_directory, "raw_sync", "create", "post"
            ),
            "follow": os.path.join(
                root_local_data_directory, "raw_sync", "create", "follow"
            ),
            "reply": os.path.join(
                root_local_data_directory, "raw_sync", "create", "reply"
            ),
            "repost": os.path.join(
                root_local_data_directory, "raw_sync", "create", "repost"
            ),
            "block": os.path.join(
                root_local_data_directory, "raw_sync", "create", "block"
            ),
            # "like_on_user_post": os.path.join(
            #     root_local_data_directory,
            #     "raw_sync",
            #     "create",
            #     "like_on_user_post",
            # ),
            # "reply_to_user_post": os.path.join(
            #     root_local_data_directory,
            #     "raw_sync",
            #     "create",
            #     "reply_to_user_post",
            # ),
        },
    },
    "study_user_likes": {
        "local_prefix": os.path.join(
            root_local_data_directory, "raw_sync", "create", "like"
        ),
        "primary_key": "uri",
        "timestamp_field": "synctimestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "author": "string",
            "cid": "string",
            "record": "string",
            "uri": "string",
            "synctimestamp": "string",
        },
    },
    "study_user_reposts": {},
    "study_user_like_on_user_post": {
        "local_prefix": os.path.join(
            root_local_data_directory,
            "raw_sync",
            "create",
            "like_on_user_post",
        ),
        "primary_key": "uri",
        "timestamp_field": "synctimestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "author": "string",
            "cid": "string",
            "record": "string",
            "uri": "string",
            "synctimestamp": "string",
        },
    },
    "study_user_reply_to_user_post": {
        "local_prefix": os.path.join(
            root_local_data_directory,
            "raw_sync",
            "create",
            "reply_to_user_post",
        ),
        "s3_prefix": "",
        "glue_table_name": "",
        "primary_key": "uri",
        "timestamp_field": "synctimestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "cid": "string",
            "indexed_at": "string",
            "author_did": "string",
            "author_handle": "string",
            "author_avatar": "string",
            "author_display_name": "string",
            "created_at": "string",
            "text": "string",
            "embed": "string",
            "entities": "string",
            "facets": "string",
            "labels": "string",
            "langs": "string",
            "reply_parent": "string",
            "reply_root": "string",
            "tags": "string",
            "synctimestamp": "string",
            "url": "string",
            "source": "string",
            "like_count": "Int64",
            "reply_count": "Int64",
            "repost_count": "Int64",
            "partition_date": "string",
        },
    },
    "sync_most_liked_posts": {
        "local_prefix": os.path.join(root_local_data_directory, "sync", "most_liked"),
        "s3_prefix": "",
        "glue_table_name": "",
        "primary_key": "uri",
        "timestamp_field": "synctimestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "cid": "string",
            "indexed_at": "string",
            "author_did": "string",
            "author_handle": "string",
            "author_avatar": "string",
            "author_display_name": "string",
            "created_at": "string",
            "text": "string",
            "embed": "string",
            "entities": "string",
            "facets": "string",
            "labels": "string",
            "langs": "string",
            "reply_parent": "string",
            "reply_root": "string",
            "tags": "string",
            "synctimestamp": "string",
            "url": "string",
            "source": "string",
            "like_count": "Int64",
            "reply_count": "Int64",
            "repost_count": "Int64",
        },
    },
    # user_session_logs shouldn't be deduped, each row already is
    # unique. Just need to compress.
    "user_session_logs": {
        "local_prefix": os.path.join(root_local_data_directory, "user_session_logs"),
        "s3_prefix": "user_session_logs",
        "glue_table_name": "user_session_logs",
        "primary_key": "",
        "timestamp_field": "timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "user_did": "string",
            "cursor": "string",
            "limit": "Int64",
            "feed_length": "Int64",
            "feed": "string",  # JSON-dumped list of posts
            "timestamp": "string",
        },
    },
    "feed_analytics": {
        "local_prefix": os.path.join(root_local_data_directory, "feed_analytics"),
        "s3_prefix": "feed_analytics",
        "glue_table_name": "feed_generation_session_analytics",
        "primary_key": "",
        "timestamp_field": "session_timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "total_feeds": "Int64",
            "total_posts": "Int64",
            "total_in_network_posts": "Int64",
            "total_in_network_posts_prop": "Float64",
            "total_unique_engagement_uris": "Int64",
            "total_unique_treatment_uris": "Int64",
            "prop_overlap_treatment_uris_in_engagement_uris": "Float64",
            "prop_overlap_engagement_uris_in_treatment_uris": "Float64",
            "total_feeds_per_condition": "string",
            "session_timestamp": "string",
        },
    },
    "daily_superposters": {
        "local_prefix": os.path.join(root_local_data_directory, "daily_superposters"),
        "s3_prefix": "daily_superposters",
        "glue_table_name": "daily_superposters",
        "primary_key": "",
        "timestamp_field": "insert_date_timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "insert_date": "string",
            "insert_date_timestamp": "string",
            "superposters": "string",
            "method": "string",
            "top_n_percent": "Float64",
            "threshold": "Int64",
        },
    },
    "post_scores": {
        "local_prefix": os.path.join(root_local_data_directory, "post_scores"),
        "s3_prefix": "post_scores",
        "glue_table_name": "post_scores",
        "primary_key": "uri",
        "timestamp_field": "scored_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "text": "string",
            "engagement_score": "Float64",
            "treatment_score": "Float64",
            "source": "string",
            "scored_timestamp": "string",
        },
    },
    "consolidated_enriched_post_records": {
        "local_prefix": os.path.join(
            root_local_data_directory, "consolidated_enriched_post_records"
        ),
        "s3_prefix": "consolidated_enriched_post_records",
        "glue_table_name": "consolidated_enriched_post_records",
        "primary_key": "uri",
        "timestamp_field": "consolidation_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        # https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#basics-dtypes
        # https://stackoverflow.com/questions/60377531/pandas-valueerror-integer-column-has-na-values-in-column-2
        "dtypes_map": {
            "uri": "string",
            "cid": "string",
            "indexed_at": "string",
            "author_did": "string",
            "author_handle": "string",
            "author_avatar": "string",
            "author_display_name": "string",
            "created_at": "string",
            "text": "string",
            "embed": "string",
            "entities": "string",
            "facets": "string",
            "labels": "string",
            "langs": "string",
            "reply_parent": "string",
            "reply_root": "string",
            "tags": "string",
            "synctimestamp": "string",
            "url": "string",
            "source": "string",
            "like_count": "Int64",
            "reply_count": "Int64",
            "repost_count": "Int64",
            "passed_filters": "bool",
            "filtered_at": "string",
            "filtered_by_func": "string",
            "preprocessing_timestamp": "string",
            "llm_model_name": "string",
            "sociopolitical_was_successfully_labeled": "bool",
            "sociopolitical_reason": "string",
            "sociopolitical_label_timestamp": "string",
            "political_ideology_label": "string",
            "perspective_was_successfully_labeled": "bool",
            "perspective_reason": "string",
            "perspective_label_timestamp": "string",
            "prob_toxic": "Float64",
            "prob_severe_toxic": "Float64",
            "prob_identity_attack": "Float64",
            "prob_insult": "Float64",
            "prob_profanity": "Float64",
            "prob_threat": "Float64",
            "prob_affinity": "Float64",
            "prob_compassion": "Float64",
            "prob_constructive": "Float64",
            "prob_curiosity": "Float64",
            "prob_nuance": "Float64",
            "prob_personal_story": "Float64",
            "prob_reasoning": "Float64",
            "prob_respect": "Float64",
            "prob_alienation": "Float64",
            "prob_fearmongering": "Float64",
            "prob_generalization": "Float64",
            "prob_moral_outrage": "Float64",
            "prob_scapegoating": "Float64",
            "prob_sexually_explicit": "Float64",
            "prob_flirtation": "Float64",
            "prob_spam": "Float64",
            "similarity_score": "Float64",
            "most_liked_average_embedding_key": "string",
            "consolidation_timestamp": "string",
            "partition_date": "string",
        },
    },
    "ml_inference_perspective_api": {
        "local_prefix": os.path.join(
            root_local_data_directory, "ml_inference_perspective_api"
        ),
        "s3_prefix": "ml_inference_perspective_api",
        "glue_table_name": "ml_inference_perspective_api",
        "primary_key": "uri",
        "timestamp_field": "preprocessing_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "text": "string",
            "preprocessing_timestamp": "string",
            "was_successfully_labeled": "bool",
            "reason": "string",
            "label_timestamp": "string",
            "prob_toxic": "Float64",
            "prob_severe_toxic": "Float64",
            "prob_identity_attack": "Float64",
            "prob_insult": "Float64",
            "prob_profanity": "Float64",
            "prob_threat": "Float64",
            "prob_affinity": "Float64",
            "prob_compassion": "Float64",
            "prob_constructive": "Float64",
            "prob_curiosity": "Float64",
            "prob_nuance": "Float64",
            "prob_personal_story": "Float64",
            "prob_reasoning": "Float64",
            "prob_respect": "Float64",
            "prob_alienation": "Float64",
            "prob_fearmongering": "Float64",
            "prob_generalization": "Float64",
            "prob_moral_outrage": "Float64",
            "prob_scapegoating": "Float64",
            "prob_sexually_explicit": "Float64",
            "prob_flirtation": "Float64",
            "prob_spam": "Float64",
            "source": "string",
            "partition_date": "string",
        },
        "subpaths": {
            "firehose": os.path.join(
                root_local_data_directory, "ml_inference_perspective_api", "firehose"
            ),
            "most_liked": os.path.join(
                root_local_data_directory, "ml_inference_perspective_api", "most_liked"
            ),
        },
    },
    "ml_inference_sociopolitical": {
        "local_prefix": os.path.join(
            root_local_data_directory, "ml_inference_sociopolitical"
        ),
        "s3_prefix": "ml_inference_sociopolitical",
        "glue_table_name": "ml_inference_sociopolitical",
        "primary_key": "uri",
        "timestamp_field": "preprocessing_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "text": "string",
            "preprocessing_timestamp": "string",
            "llm_model_name": "string",
            "was_successfully_labeled": "bool",
            "reason": "string",
            "label_timestamp": "string",
            "is_sociopolitical": "bool",
            "political_ideology_label": "string",
            "source": "string",
            "partition_date": "string",
        },
        "subpaths": {
            "firehose": os.path.join(
                root_local_data_directory, "ml_inference_sociopolitical", "firehose"
            ),
            "most_liked": os.path.join(
                root_local_data_directory, "ml_inference_sociopolitical", "most_liked"
            ),
        },
    },
    "ml_inference_ime": {
        "local_prefix": os.path.join(root_local_data_directory, "ml_inference_ime"),
        "s3_prefix": "ml_inference_ime",
        "glue_table_name": "ml_inference_ime",
        "primary_key": "uri",
        "timestamp_field": "preprocessing_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "text": "string",
            "preprocessing_timestamp": "string",
            "prob_emotion": "Float64",
            "prob_intergroup": "Float64",
            "prob_moral": "Float64",
            "prob_other": "Float64",
            "label_emotion": "Int64",
            "label_intergroup": "Int64",
            "label_moral": "Int64",
            "label_other": "Int64",
            "source": "string",
            "label_timestamp": "string",
            "partition_date": "string",
        },
        "subpaths": {
            "firehose": os.path.join(
                root_local_data_directory, "ml_inference_ime", "firehose"
            ),
            "most_liked": os.path.join(
                root_local_data_directory, "ml_inference_ime", "most_liked"
            ),
        },
    },
    "in_network_user_activity": {
        "local_prefix": os.path.join(
            root_local_data_directory, "in_network_user_activity"
        ),
        "s3_prefix": os.path.join("in_network_user_activity", "create", "post"),
        "glue_table_name": "in_network_firehose_sync_posts",
        "primary_key": "uri",
        "timestamp_field": "synctimestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "cid": "string",
            "indexed_at": "string",
            "author_did": "string",
            "author_handle": "string",
            "author_avatar": "string",
            "author_display_name": "string",
            "created_at": "string",
            "text": "string",
            "embed": "string",
            "entities": "string",
            "facets": "string",
            "labels": "string",
            "langs": "string",
            "reply_parent": "string",
            "reply_root": "string",
            "tags": "string",
            "synctimestamp": "string",
            "url": "string",
            "source": "string",
            "like_count": "Int64",
            "reply_count": "Int64",
            "repost_count": "Int64",
            "partition_date": "string",
        },
    },
    # each row is a unique relationship, so no deduping required.
    "scraped_user_social_network": {
        "local_prefix": os.path.join(
            root_local_data_directory, "scraped_user_social_network"
        ),
        "s3_prefix": "scraped-user-social-network",
        "glue_table_name": "user_social_networks",
        "primary_key": "",
        "timestamp_field": "insert_timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        # string is more memory-efficient for actual strings, and collapses
        # to
        "dtypes_map": {
            "follow_handle": "string",
            "follow_url": "string",
            "follow_did": "string",
            "follower_handle": "string",
            "follower_url": "string",
            "follower_did": "string",
            "insert_timestamp": "string",
            "relationship_to_study_user": "string",
            "partition_date": "string",
        },
    },
    "preprocessed_posts": {
        "local_prefix": os.path.join(root_local_data_directory, "preprocessed_posts"),
        "s3_prefix": os.path.join("preprocessed_data", "preprocessed_posts"),
        "glue_table_name": "preprocessed_posts",
        "primary_key": "uri",
        "timestamp_field": "preprocessing_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "cid": "string",
            "indexed_at": "string",
            "author_did": "string",
            "author_handle": "string",
            "author_avatar": "string",
            "author_display_name": "string",
            "created_at": "string",
            "text": "string",
            "embed": "string",
            "entities": "string",
            "facets": "string",
            "labels": "string",
            "langs": "string",
            "reply_parent": "string",
            "reply_root": "string",
            "tags": "string",
            "synctimestamp": "string",
            "url": "string",
            "source": "string",
            "like_count": "Int64",
            "reply_count": "Int64",
            "repost_count": "Int64",
            "passed_filters": "bool",
            "filtered_at": "string",
            "filtered_by_func": "string",
            "preprocessing_timestamp": "string",
            "partition_date": "string",
        },
        "subpaths": {
            "firehose": os.path.join(
                root_local_data_directory, "preprocessed_posts", "firehose"
            ),
            "most_liked": os.path.join(
                root_local_data_directory, "preprocessed_posts", "most_liked"
            ),
        },
    },
    "aggregated_study_user_activities": {
        "local_prefix": os.path.join(
            root_local_data_directory, "aggregated_study_user_activities"
        ),
        "s3_prefix": "",
        "glue_table_name": "",
        "primary_key": "",  # NOTE: make a compound key? Either pass in multiple cols or comma-join the fields?
        "timestamp_field": "activity_timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "author_did": "string",
            "author_handle": "string",
            "data_type": "string",
            "data": "string",
            "activity_timestamp": "string",  # actual timestamp of the activity itself.
            "insert_timestamp": "string",  # timestamp it was inserted into 'aggregated_study_user_activities'
            "partition_date": "string",
        },
    },
    "generated_feeds": {
        "local_prefix": os.path.join(root_local_data_directory, "generated_feeds"),
        "s3_prefix": "generated_feeds",
        "glue_table_name": "generated_feeds",
        "primary_key": "feed_id",
        "timestamp_field": "feed_generation_timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "feed_id": "string",
            "user": "string",
            "bluesky_handle": "string",
            "bluesky_user_did": "string",
            "condition": "string",
            "feed_statistics": "string",
            "feed": "string",
            "feed_generation_timestamp": "string",
        },
    },
    "fetch_posts_used_in_feeds": {
        "local_prefix": os.path.join(
            root_local_data_directory, "fetch_posts_used_in_feeds"
        ),
        "s3_prefix": "fetch_posts_used_in_feeds",
        "glue_table_name": "fetch_posts_used_in_feeds",
        "primary_key": "uri",
        "timestamp_field": "partition_date",
        "timestamp_format": "%Y-%m-%d",  # the data will already be assigned partition dates, in %Y-%m-%d format
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "partition_date": "string",
        },
    },
    "preprocessed_posts_used_in_feeds": {
        "local_prefix": os.path.join(
            root_local_data_directory, "preprocessed_posts_used_in_feeds"
        ),
        "s3_prefix": "preprocessed_posts_used_in_feeds",
        "glue_table_name": "preprocessed_posts_used_in_feeds",
        "primary_key": "uri",
        "timestamp_field": "partition_date",
        "timestamp_format": "%Y-%m-%d",  # the data will already be assigned partition dates, in %Y-%m-%d format
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "cid": "string",
            "indexed_at": "string",
            "author_did": "string",
            "author_handle": "string",
            "author_avatar": "string",
            "author_display_name": "string",
            "created_at": "string",
            "text": "string",
            "embed": "string",
            "entities": "string",
            "facets": "string",
            "labels": "string",
            "langs": "string",
            "reply_parent": "string",
            "reply_root": "string",
            "tags": "string",
            "synctimestamp": "string",
            "url": "string",
            "source": "string",
            "like_count": "Int64",
            "reply_count": "Int64",
            "repost_count": "Int64",
            "passed_filters": "bool",
            "filtered_at": "string",
            "filtered_by_func": "string",
            "preprocessing_timestamp": "string",
            "partition_date": "string",
        },
    },
    "generated_user_session_logs": {
        "local_prefix": os.path.join(
            root_local_data_directory, "generated_user_session_logs"
        ),
        "s3_prefix": "generated_user_session_logs",
        "glue_table_name": "generated_user_session_logs",
        "primary_key": "",
        "timestamp_field": "timestamp",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "user_did": "string",
            "cursor": "string",
            "limit": "Int64",
            "feed_length": "Int64",
            "feed": "string",
            "timestamp": "string",
        },
    },
    # TODO:  check if this is correct
    "linked_feeds_to_user_session_logs": {
        "local_prefix": os.path.join(
            root_local_data_directory, "linked_feeds_to_user_session_logs"
        ),
        "s3_prefix": "linked_feeds_to_user_session_logs",
        "glue_table_name": "linked_feeds_to_user_session_logs",
        "primary_key": "feed_id",
        "timestamp_field": "feed_generation_timestamp",  # TODO: check...
        "skip_deduping": True,
        "pydantic_model": "",
    },
    # TODO:  check if this is correct
    "linked_posts_to_feeds": {
        "local_prefix": os.path.join(
            root_local_data_directory, "linked_posts_to_feeds"
        ),
        "s3_prefix": "linked_posts_to_feeds",
        "glue_table_name": "linked_posts_to_feeds",
        "primary_key": "uri",
        "timestamp_field": "partition_date",  # TODO: check...
        "skip_deduping": True,
        "pydantic_model": "",
    },
    "ml_inference_valence_classifier": {
        "local_prefix": os.path.join(
            root_local_data_directory, "ml_inference_valence_classifier"
        ),
        "s3_prefix": "ml_inference_valence_classifier",
        "glue_table_name": "ml_inference_valence_classifier",
        "primary_key": "uri",
        "timestamp_field": "preprocessing_timestamp",
        "skip_deduping": False,
        "pydantic_model": "",
        "dtypes_map": {
            "uri": "string",
            "text": "string",
            "preprocessing_timestamp": "string",
            "valence_label": "string",
            "compound": "Float64",
            "was_successfully_labeled": "bool",
            "reason": "string",
            "label_timestamp": "string",
            "source": "string",
            "partition_date": "string",
        },
    },
    "author_to_average_toxicity_outrage": {
        "local_prefix": os.path.join(
            root_local_data_directory, "author_to_average_toxicity_outrage"
        ),
        "s3_prefix": "author_to_average_toxicity_outrage",
        "glue_table_name": "author_to_average_toxicity_outrage",
        "primary_key": "author_did",
        "timestamp_field": "partition_date",
        "skip_deduping": True,
        "pydantic_model": "",
        "dtypes_map": {
            "author_did": "string",
            "partition_date": "string",
            "total_labeled_posts": "Int64",
            "average_toxicity": "Float64",
            "average_outrage": "Float64",
        },
    },
}
